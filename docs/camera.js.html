<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>camera.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Controller_Schedule.html">Controller/Schedule</a><ul class='methods'><li data-type='method'><a href="module-Controller_Schedule.html#~calibrateTimezone">calibrateTimezone</a></li><li data-type='method'><a href="module-Controller_Schedule.html#~cleanupCVWaitList">cleanupCVWaitList</a></li><li data-type='method'><a href="module-Controller_Schedule.html#~cleanupDropin">cleanupDropin</a></li><li data-type='method'><a href="module-Controller_Schedule.html#~downloadIDImages">downloadIDImages</a></li><li data-type='method'><a href="module-Controller_Schedule.html#~followUp">followUp</a></li><li data-type='method'><a href="module-Controller_Schedule.html#~generateInvoices">generateInvoices</a></li><li data-type='method'><a href="module-Controller_Schedule.html#~scheduleNextRun">scheduleNextRun</a></li><li data-type='method'><a href="module-Controller_Schedule.html#~sendNotifications">sendNotifications</a></li><li data-type='method'><a href="module-Controller_Schedule.html#~sendPN">sendPN</a></li></ul></li><li><a href="module-Controller_authentication.html">Controller/authentication</a></li><li><a href="module-Controller_button.html">Controller/button</a><ul class='methods'><li data-type='method'><a href="module-Controller_button.html#~statusButoon">statusButoon</a></li></ul></li><li><a href="module-Controller_camera.html">Controller/camera</a><ul class='methods'><li data-type='method'><a href="module-Controller_camera.html#~countRecords">countRecords</a></li><li data-type='method'><a href="module-Controller_camera.html#~createCameraZone">createCameraZone</a></li><li data-type='method'><a href="module-Controller_camera.html#~createNewCamera">createNewCamera</a></li><li data-type='method'><a href="module-Controller_camera.html#~editCamera">editCamera</a></li><li data-type='method'><a href="module-Controller_camera.html#~enableCamera">enableCamera</a></li><li data-type='method'><a href="module-Controller_camera.html#~generateStreamURL">generateStreamURL</a></li><li data-type='method'><a href="module-Controller_camera.html#~getKinesesStreamingUrl">getKinesesStreamingUrl</a></li><li data-type='method'><a href="module-Controller_camera.html#~getNextMonitorId">getNextMonitorId</a></li><li data-type='method'><a href="module-Controller_camera.html#~getRecords">getRecords</a></li><li data-type='method'><a href="module-Controller_camera.html#~getToken">getToken</a></li><li data-type='method'><a href="module-Controller_camera.html#~pad">pad</a></li><li data-type='method'><a href="module-Controller_camera.html#~refreshToken">refreshToken</a></li><li data-type='method'><a href="module-Controller_camera.html#~reloadCameraStreams">reloadCameraStreams</a></li><li data-type='method'><a href="module-Controller_camera.html#~removeCamera">removeCamera</a></li><li data-type='method'><a href="module-Controller_camera.html#~triggerCameraStreams">triggerCameraStreams</a></li></ul></li><li><a href="module-Controller_contact.html">Controller/contact</a><ul class='methods'><li data-type='method'><a href="module-Controller_contact.html#~convertJsonToCsv">convertJsonToCsv</a></li><li data-type='method'><a href="module-Controller_contact.html#~getById">getById</a></li><li data-type='method'><a href="module-Controller_contact.html#~getContact">getContact</a></li><li data-type='method'><a href="module-Controller_contact.html#~getContactSub">getContactSub</a></li><li data-type='method'><a href="module-Controller_contact.html#~getUpdate">getUpdate</a></li><li data-type='method'><a href="module-Controller_contact.html#~toCsv">toCsv</a></li><li data-type='method'><a href="module-Controller_contact.html#~updateContactSub">updateContactSub</a></li><li data-type='method'><a href="module-Controller_contact.html#~validateIdLoad">validateIdLoad</a></li></ul></li><li><a href="module-Controller_dashboard.html">Controller/dashboard</a><ul class='methods'><li data-type='method'><a href="module-Controller_dashboard.html#~getDashboardStats">getDashboardStats</a></li></ul></li><li><a href="module-Controller_invoices.html">Controller/invoices</a><ul class='methods'><li data-type='method'><a href="module-Controller_invoices.html#~createInvoice">createInvoice</a></li><li data-type='method'><a href="module-Controller_invoices.html#~viewInvoices">viewInvoices</a></li><li data-type='method'><a href="module-Controller_invoices.html#~viewInvoicesById">viewInvoicesById</a></li><li data-type='method'><a href="module-Controller_invoices.html#~viewInvoicesByUser">viewInvoicesByUser</a></li></ul></li><li><a href="module-Controller_keypad.html">Controller/keypad</a><ul class='methods'><li data-type='method'><a href="module-Controller_keypad.html#~createPasscode">createPasscode</a></li><li data-type='method'><a href="module-Controller_keypad.html#~deletePasscode">deletePasscode</a></li><li data-type='method'><a href="module-Controller_keypad.html#~listPasscodes">listPasscodes</a></li></ul></li><li><a href="module-Controller_lock_august_index.html">Controller/lock/august/index</a><ul class='methods'><li data-type='method'><a href="module-Controller_lock_august_index.html#~getLogs">getLogs</a></li><li data-type='method'><a href="module-Controller_lock_august_index.html#~lockStatus">lockStatus</a></li><li data-type='method'><a href="module-Controller_lock_august_index.html#~sendCommand">sendCommand</a></li></ul></li><li><a href="module-Controller_lock_august_token.html">Controller/lock/august/token</a><ul class='methods'><li data-type='method'><a href="module-Controller_lock_august_token.html#~confirm">confirm</a></li><li data-type='method'><a href="module-Controller_lock_august_token.html#~session">session</a></li><li data-type='method'><a href="module-Controller_lock_august_token.html#~validate">validate</a></li></ul></li><li><a href="module-Controller_lock_index.html">Controller/lock/index</a><ul class='methods'><li data-type='method'><a href="module-Controller_lock_index.html#~generateSign">generateSign</a></li><li data-type='method'><a href="module-Controller_lock_index.html#~getDevicesStatus">getDevicesStatus</a></li><li data-type='method'><a href="module-Controller_lock_index.html#~getLogs">getLogs</a></li><li data-type='method'><a href="module-Controller_lock_index.html#~getStatus">getStatus</a></li><li data-type='method'><a href="module-Controller_lock_index.html#~sendCommand">sendCommand</a></li><li data-type='method'><a href="module-Controller_lock_index.html#~toggleLock">toggleLock</a></li></ul></li><li><a href="module-Controller_lock_switchbot.html">Controller/lock/switchbot</a><ul class='methods'><li data-type='method'><a href="module-Controller_lock_switchbot.html#~generateSign">generateSign</a></li><li data-type='method'><a href="module-Controller_lock_switchbot.html#~getDevices">getDevices</a></li><li data-type='method'><a href="module-Controller_lock_switchbot.html#~getDevicesStatus">getDevicesStatus</a></li><li data-type='method'><a href="module-Controller_lock_switchbot.html#~sendCommand">sendCommand</a></li></ul></li><li><a href="module-Controller_meeting.html">Controller/meeting</a><ul class='methods'><li data-type='method'><a href="module-Controller_meeting.html#~meetingStats">meetingStats</a></li><li data-type='method'><a href="module-Controller_meeting.html#~sendTempCommand">sendTempCommand</a></li></ul></li><li><a href="module-Controller_notification.html">Controller/notification</a><ul class='methods'><li data-type='method'><a href="module-Controller_notification.html#~sendConfirmationEmail">sendConfirmationEmail</a></li><li data-type='method'><a href="module-Controller_notification.html#~sendConfirmationSMS">sendConfirmationSMS</a></li><li data-type='method'><a href="module-Controller_notification.html#~sendEmail">sendEmail</a></li><li data-type='method'><a href="module-Controller_notification.html#~sendSms">sendSms</a></li></ul></li><li><a href="module-Controller_order.html">Controller/order</a><ul class='methods'><li data-type='method'><a href="module-Controller_order.html#~createAndNotify">createAndNotify</a></li><li data-type='method'><a href="module-Controller_order.html#~formatOrderDetails">formatOrderDetails</a></li><li data-type='method'><a href="module-Controller_order.html#~formatUserDetails">formatUserDetails</a></li><li data-type='method'><a href="module-Controller_order.html#~updateAndNotify">updateAndNotify</a></li></ul></li><li><a href="module-Controller_property.html">Controller/property</a><ul class='methods'><li data-type='method'><a href="module-Controller_property.html#~assignPropertyToUser">assignPropertyToUser</a></li><li data-type='method'><a href="module-Controller_property.html#~calcAvailability">calcAvailability</a></li><li data-type='method'><a href="module-Controller_property.html#~calcMonthAvailability">calcMonthAvailability</a></li><li data-type='method'><a href="module-Controller_property.html#~cloneProperty">cloneProperty</a></li><li data-type='method'><a href="module-Controller_property.html#~getSinglePublicProperty">getSinglePublicProperty</a></li><li data-type='method'><a href="module-Controller_property.html#~makeBook">makeBook</a></li><li data-type='method'><a href="module-Controller_property.html#~newProperty">newProperty</a></li><li data-type='method'><a href="module-Controller_property.html#~propertiesPublic">propertiesPublic</a></li><li data-type='method'><a href="module-Controller_property.html#~propertiesUser">propertiesUser</a></li><li data-type='method'><a href="module-Controller_property.html#~property">property</a></li><li data-type='method'><a href="module-Controller_property.html#~propertyAssignList">propertyAssignList</a></li><li data-type='method'><a href="module-Controller_property.html#~propertyList">propertyList</a></li><li data-type='method'><a href="module-Controller_property.html#~propertyListCustomSearch">propertyListCustomSearch</a></li><li data-type='method'><a href="module-Controller_property.html#~updateProperty">updateProperty</a></li><li data-type='method'><a href="module-Controller_property.html#~updatePropertyKit">updatePropertyKit</a></li></ul></li><li><a href="module-Controller_shipment.html">Controller/shipment</a><ul class='methods'><li data-type='method'><a href="module-Controller_shipment.html#~formattedShipment">formattedShipment</a></li><li data-type='method'><a href="module-Controller_shipment.html#~sendShipmentNotification">sendShipmentNotification</a></li></ul></li><li><a href="module-Controller_transactions.html">Controller/transactions</a><ul class='methods'><li data-type='method'><a href="module-Controller_transactions.html#~createTransaction">createTransaction</a></li><li data-type='method'><a href="module-Controller_transactions.html#~viewTransactionByHardware">viewTransactionByHardware</a></li><li data-type='method'><a href="module-Controller_transactions.html#~viewTransactionById">viewTransactionById</a></li><li data-type='method'><a href="module-Controller_transactions.html#~viewTransactionByProperty">viewTransactionByProperty</a></li><li data-type='method'><a href="module-Controller_transactions.html#~viewTransactions">viewTransactions</a></li></ul></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">camera.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Handles camera-related operations, including enabling, disabling, and deleting cameras.
 * @module Controller/camera
 */
const request = require('request');
const crypto = require('crypto');
const ObjectId = require('mongoose').Types.ObjectId;
const Hardware = require('../models/hardware');
const config = require('../config');
// const auth = require('../middlewares/auth');
const { KinesisVideoArchivedMediaClient, GetHLSStreamingSessionURLCommand, ListFragmentsCommand, GetMediaForFragmentListCommand } = require("@aws-sdk/client-kinesis-video-archived-media");
const { KinesisVideoClient, GetDataEndpointCommand } = require("@aws-sdk/client-kinesis-video");
const { createWriteStream } = require('fs');
const { promisify } = require('util');
const pipeline = promisify(require('stream').pipeline);
const { streamToBuffer } = require('../helpers/camera');


let token = null

module.exports = {
    enable: enableCamera,
    getToken: getToken,
    delete: removeCamera,
    getRecords: getRecords,
    countRecords: countRecords,
    getKinesesStreamingUrl,
    triggerCameraStreams,
    reloadCameraStreams,
    getListFragments,
    getStoredHLS
}

/**
 * Gets the current authentication token for the Zoneminder API.
 * @returns {string} The current authentication token for the Zoneminder API.
 */
function getToken() {
    return token;
}

/**
 * Refreshes the authentication token by sending a POST request to a specified authentication endpoint.
 * This function sends user credentials to obtain a new access token and updates the global 'token' variable.
 * It handles any errors that might occur during the request and attempts to parse the JSON response to extract the access token.
 * If successful, it updates the token; if not, it logs the error.
 */
function refreshToken() {
    request.post({
        url: `${process.env.zmHost}/zm/api/host/login.json`,
        form: {
            user: process.env.zmUser,
            pass: process.env.zmPass
        }
    }, (err, httpResponse, body) => {
        if (err) {
            console.log(err)
        } else {
            try {
                token = JSON.parse(body).access_token
            } catch (e) {

            }
        }
    });
}

refreshToken();

setInterval(function () {
    refreshToken();
}, 1000 * 60 * 60)

/**
 * Generates a streaming URL for a given camera object based on its configuration properties.
 * The function constructs a URL by checking if a direct link is provided; if not, it assembles the URL
 * using camera's protocol, hostname, port, and recording path credentials. This URL formation is customizable
 * depending on the camera's credentials, protocol, and connection specifics.
 * If no specific properties are set, default values are used for protocol, hostname, and port.
 * 
 * @param {Object} camera - The camera object containing configuration properties like protocol, hostname, credentials, etc.
 * @returns {string} The fully formed URL for streaming camera footage.
 */
function generateStreamURL(camera) {
    let link = '';
    if (!camera.link || camera.link.length == 0) {
        camera.protocol = camera.protocol || 'rtsp';
        camera.hostname = camera.hostname || '&lt;ipaddress>';
        camera.port = camera.port || '554';
        camera.recordPath = camera.recordPath || '';
        let credentials = '';
        if (camera.username &amp;&amp; camera.password) {
            credentials = camera.username + ':' + camera.password + '@'
        }
        link = camera.protocol + '://' + credentials + camera.hostname + ':' + camera.port + camera.recordPath
    } else {
        link = camera.link;
    }
    return link;
}

/**
 * Activates a camera within the system based on its hardware configuration and current status.
 * This function checks if the camera is categorized properly and if it's marked as active. Depending on whether
 * the camera is already registered in the system (checked via `monitorId`), it updates or creates a new camera configuration.
 * Uses `Hardware.findByIdAndUpdate` to update the database with new or modified camera configurations and handles the response
 * through a callback function.
 * 
 * @param {Object} hardware - The hardware document representing the camera.
 * @param {Function} cb - Callback function to handle the result after database operations.
 */
function enableCamera(hardware, cb) {

    if (hardware.category !== 'camera' || hardware.status !== 'active') {
        return;
    }


    if (hardware.zm.monitorId) {
        Hardware.findByIdAndUpdate(
            { _id: hardware._id },
            { $set: { 'zm.active': false } },
            { upsert: false, new: true })
            .exec(function (err, hw) {
                editCamera(hw, cb)
            })
        return;
    } else {
        getNextMonitorId((err, id) => {
            if (err) {
                console.log(err);
            } else {
                hardware.zm.monitorId = id;
                Hardware.findByIdAndUpdate(
                    { _id: hardware._id },
                    { $set: { 'zm.monitorId': id, 'zm.active': true } },
                    { upsert: false, new: true }
                )
                    .exec(function (err, hw) {
                        createNewCamera(hw, cb)
                    })
            }
        })
    }

}

/**
 * Updates an existing camera's configuration on the monitoring service based on the provided hardware object.
 * This function sends a PUT request to update camera settings such as function mode and stream URL.
 * The URL for the camera is generated using the generateStreamURL function. The update request requires authentication,
 * which is handled via a token. After the update, the response is processed through a callback function.
 *
 * @param {Object} camera - The camera hardware object containing the new configuration settings.
 * @param {Function} cb - Callback function to handle the response or error from the monitoring service.
 */
function editCamera(camera, cb) {
    const zmRoot = `${process.env.zmHost}/zm/api`;

    let cameraFunction = 'None';

    if (camera.zm.status === 'enabled') {
        cameraFunction = 'Modect';
    }

    const link = generateStreamURL(camera);

    request.put({
        url: `${zmRoot}/monitors/${camera.zm.monitorId}.json?token=${token}`,
        form: {
            Monitor: {
                Function: cameraFunction,
                Name: `${camera.name} (${camera._id})`,
                'Path': link,
            }
        }
    }, (err, httpResponse, body) => {
        cb(err, body)
    });
}

/**
 * Deletes a camera's configuration from the monitoring system using a DELETE request.
 * The function constructs the request URL using the camera's monitor ID and the authentication token.
 * After the deletion request, the result or any errors encountered are handled by a callback function.
 *
 * @param {Object} camera - The camera hardware object to be deleted.
 * @param {Function} cb - Callback function to process the response or error.
 */
function removeCamera(camera, cb) {

    let zmRoot = `${process.env.zmHost}/zm/api`;

    request.delete({
        url: `${zmRoot}/monitors/${camera.zm.monitorId}.json?token=${token}`
    }, (err, httpResponse, body) => {
        cb(err, body)
    });

}

/**
 * Registers a new camera in the monitoring system by sending a POST request with the camera's configuration.
 * The configuration includes details like monitor function, name, and streaming URL which is generated dynamically.
 * It also handles zones for the camera after creation. Any responses or errors from the server are processed through
 * the provided callback function.
 *
 * @param {Object} camera - The camera hardware object to be registered.
 * @param {Function} cb - Callback function to handle the creation response or errors.
 */
function createNewCamera(camera, cb) {

    let zmRoot = `${process.env.zmHost}/zm/api`;

    const link = generateStreamURL(camera);

    request.post({
        url: `${zmRoot}/monitors.json?token=${token}`,
        form: {
            Monitor: {
                Function: 'Modect',
                // Function: 'Mocord',
                Name: `${camera.name} (${camera._id})`,
                Type: 'Ffmpeg',
                Id: camera.zm.monitorId + '',
                Colours: 4,
                //   VideoWriter: 2,
                //   RecordAudio: 1,
                Protocol: 'http',
                Method: 'simple',
                'Path': link,
                'Width': '768',
                'Height': '432'
            }
        }
    }, (err, httpResponse, body) => {
        createCameraZone(camera);
        cb(err, body)
    });

}

/**
 * Configures zones for a newly created or updated camera in the monitoring system.
 * This function sends a POST request to define zones, specifying parameters like name, type, and coordinates,
 * which help in defining the active monitoring areas of the camera. This configuration is part of the camera setup
 * in the monitoring system and is essential for motion detection settings.
 *
 * @param {Object} camera - The camera hardware object for which zones are being configured.
 */
function createCameraZone(camera) {
    let zmRoot = `${process.env.zmHost}/zm/api`;

    request.post({
        url: `${zmRoot}/zones.json?token=${token}`,
        form: {
            Zone: {
                MonitorId: camera.zm.monitorId,
                Name: 'All',
                Type: 'Active',
                Units: 'Percent',
                NumCoords: '4',
                Coords: '0,0 767,0 767,431 0,431',
                Area: '307200',
                AlarmRGB: '16711680',
                CheckMethod: 'Blobs',
                MinPixelThreshold: '25',
                MaxPixelThreshold: '',
                MinAlarmPixels: '9216',
                MaxAlarmPixels: '230400',
                FilterX: '3',
                FilterY: '3',
                MinFilterPixels: '9216',
                MaxFilterPixels: '230400',
                MinBlobPixels: '6144',
                MaxBlobPixels: '',
                MinBlobs: '1',
                MaxBlobs: '',
                OverloadFrames: '0'
            }
        }
    }, (err, httpResponse, body) => {
    });
}

/**
 * Retrieves the next available monitor ID for a new camera by querying the database for existing camera configurations.
 * This function finds the highest current monitor ID and increments it for the next camera setup, ensuring unique identifiers
 * for each camera. The result is passed through a callback function, which handles either the new ID or any errors.
 *
 * @param {Function} cb - Callback function to handle the resulting ID or an error.
 */
function getNextMonitorId(cb) {
    Hardware.find({ category: 'camera', 'zm.monitorId': { $ne: null } }).sort({ 'zm.monitorId': -1 }).limit(1).exec(function (err, hardware) {

        if (!hardware || !hardware.length || !hardware[0].zm) {
            return cb(err, 1);
        } else {
            const prevNumber = hardware[0].zm.monitorId ? hardware[0].zm.monitorId : 0;
            const nextNumber = (prevNumber) + 1;
            console.log(`Next ZM monitorId: ${nextNumber} - prev monitorId: ${prevNumber} (Camera ${hardware[0]._id})`);
            return cb(null, nextNumber);
        }
    })
}

/**
 * Retrieves event records for a specific camera from the monitoring service based on request parameters.
 * This function first validates the hardware ID and then constructs a query to fetch records.
 * It filters records based on the user's organization and role if specified, and additional time filters can be applied.
 * Requests are made to the monitoring API to fetch events within the specified time range. The response is transformed,
 * adding secure, encrypted links for accessing specific camera streams or frames.
 *
 * @param {Object} req - The request object containing parameters like user details and date filters.
 * @param {Object} res - The response object used to return the records or an error message.
 * @param {Function} next - The next middleware function in the routing chain.
 */
function getRecords(req, res, next) {
    if (!ObjectId.isValid(req.params.id)) {
        return res.status(400).end();
    }
    let query = {}
    query = { _id: req.params.id, user: req.user._id, category: 'camera', status: 'active', 'zm.monitorId': { $exists: true }, 'zm.status': 'enabled' };

    if (req.user.orgs) {
        query.user = req.user.orgs;
    }

    if (req.user.role == 'admin') {
        delete query.user;
    }

    Hardware.findOne(query).exec(function (err, hardware) {

        if (!hardware || !hardware.zm || !hardware.zm.monitorId) {
            return res.json([]);
        }

        let from = new Date(new Date().getTime() - 86400000 * 60)
        let to = new Date(new Date().getTime());
        if (req.query.from !== undefined &amp;&amp; req.query.to !== undefined) {
            from = new Date(new Date().getTime() - 86400000 * req.query.from)
            to = new Date(new Date().getTime() - 86400000 * (req.query.to));
        }

        let fromStr = [from.getFullYear(), pad(from.getMonth() + 1, 2), pad(from.getDate(), 2)].join('-') + '%20' + [pad(from.getHours() + 1, 2), pad(from.getMinutes() + 1, 2), pad(from.getSeconds() + 1, 2)].join(':')
        let toStr = [to.getFullYear(), pad(to.getMonth() + 1, 2), pad(to.getDate(), 2)].join('-') + '%20' + [pad(to.getHours() + 1, 2), pad(to.getMinutes() + 1, 2), pad(to.getSeconds() + 1, 2)].join(':')
        request.get(`${process.env.zmHost}/zm/api/events/index/MonitorId:${hardware.zm.monitorId}/StartTime%20%3E=:${fromStr}/EndTime%20%3C=:${toStr}.json?token=${token}`, function (err, response, body) {
            if (err) {
                return next(err);
            }
            let json = JSON.parse(body);
            let output = [];

            if (json.events === undefined) {
                json.events = [];
            }

            json.events.forEach(function (event) {
                let text = JSON.stringify({
                    eid: event.Event.Id,
                    monitor: event.Event.MonitorId,
                    _id: req.params.id,
                    expires: new Date().getTime() + 1000 * 60 * 60
                });

                var cipher = crypto.createCipher(config.stream.algorithm, config.stream.key);
                var encrypted = cipher.update(text, 'utf8', 'hex') + cipher.final('hex');
                event.Event.stream = `/api/camera/${req.params.id}/video?token=` + encrypted;
                event.Event.frame = `/api/camera/${req.params.id}/frame?token=` + encrypted;
                event.Event.monitor = `/api/camera/${req.params.id}/monitor?token=` + encrypted;

                output.push(event.Event);

            })


            return res.json(output)
        })
    })
}

/**
 * Counts the number of event records for a specified camera over the past hour.
 * This function validates the hardware ID and constructs a query to count events based on user and camera status.
 * It sends a request to the monitoring service's API to retrieve event counts, and the result is returned through the response object.
 * If there are any errors during the request, they are handled and passed along to the next middleware.
 *
 * @param {Object} req - The request object with user and hardware details.
 * @param {Object} res - The response object used to send the count or an error.
 * @param {Function} next - The next middleware function in the chain for error handling.
 */
function countRecords(req, res, next) {
    if (!ObjectId.isValid(req.params.id)) {
        return res.status(400).end();
    }
    let query = {}
    query = { _id: req.params.id, user: req.user._id, category: 'camera', status: 'active', 'zm.monitorId': { $exists: true }, 'zm.status': 'enabled' };

    if (req.user.orgs) {
        query.user = req.user.orgs;
    }

    if (req.user.role == 'admin') {
        delete query.user;
    }

    Hardware.findOne(query).exec(function (err, hardware) {

        if (!hardware || !hardware.zm || !hardware.zm.monitorId) {
            return res.json(0);
        }

        request.get(`${process.env.zmHost}/zm/api/events/consoleEvents/${hardware.zm.monitorId}%20hour.json?token=${token}`, function (err, response, body) {
            if (err) {
                return next(err);
            }
            let result = 0;
            let json = JSON.parse(body);
            console.log(hardware.zm.monitorId, json);
            if (json.hasOwnProperty('results')) {
                if (json['results'][hardware.zm.monitorId] === undefined) {
                    result = 0;
                } else {
                    result = Number(json['results'][hardware.zm.monitorId])
                }
            }

            return res.json(result)
        })
    })
}

/**
 * Pads a number with leading zeros to ensure it meets a specified length.
 * This utility function is often used to format numbers as strings, such as dates or times, to maintain a consistent format.
 *
 * @param {Number} n - The number to be padded.
 * @param {Number} spaces - The total desired length of the string.
 * @returns {String} The padded string.
 */
function pad(n, spaces) {
    let s = n + ''
    let a = new Array(spaces - s.length);
    a.push(s);
    return a.join('0')

}

//---------------------------------------- RAHMAN TEST FUNCTIONS ----------------------------------------------//

/**
 * Retrieves the HLS streaming URL for a specified camera from AWS Kinesis Video Streams.
 * This function first obtains the appropriate data endpoint using the camera's name,
 * then requests the HLS streaming URL, which is used for real-time video streaming in the client's application.
 * The URL expires after a specified duration and supports various stream configurations.
 *
 * @param {String} name - The name of the stream to get the URL for.
 * @returns {Promise&lt;String>} A promise that resolves with the streaming URL or an error message.
 */
// This function is used in hardware.js route to get the streaming URL for the camera page in react and the property details page in react
async function getKinesesStreamingUrl(name) {

    const configKineses = {
        region: process.env.aws_region,
        credentials: {
            accessKeyId: process.env.aws_access_key_id,
            secretAccessKey: process.env.aws_secret_access_key
        }
    }

    const client = new KinesisVideoClient(configKineses);

    try {

        // before making the GetHLSStreamingSessionURL API call, you need to call the GetDataEndpoint API to get the endpoint URL
        const getDataEndpointCommand = new GetDataEndpointCommand({
            StreamName: name,
            APIName: "GET_HLS_STREAMING_SESSION_URL" // this should be specified if you want to get the HLS streaming URL
        });

        const dataEndpointResponse = await client.send(getDataEndpointCommand);
        // console.log(dataEndpointResponse);
        const dataEndpoint = dataEndpointResponse.DataEndpoint;
        // Create a new client instance with the data endpoint
        const kinesisArchivedClient = new KinesisVideoArchivedMediaClient({
            ...configKineses,
            endpoint: dataEndpoint
        });

        // Make the GetHLSStreamingSessionURL API call and pass the input parameters for the hls streaming session
        const input = {
            StreamName: name,
            ContainerFormat: "FRAGMENTED_MP4",
            DiscontinuityMode: "ALWAYS",
            DisplayFragmentTimestamp: "NEVER",
            Expires: 43200, //12 hours
            PlaybackMode: "LIVE",

        };

        const command = new GetHLSStreamingSessionURLCommand(input);
        const response = await kinesisArchivedClient.send(command);
        if (response.$metadata.httpStatusCode !== 200) {
            return "Stream not found";
        }
        return response.HLSStreamingSessionURL;

    } catch (e) {
        return `Stream error`;
    }

}

/**
 * Triggers a remote action to start camera streaming via an AWS Lambda function.
 * This function sends a GET request to an API Gateway endpoint, which is linked to the Lambda function.
 * It handles the API key for authentication and processes the response or any errors that occur during the request.
 *
 * @param {String} deviceId - The device ID for which to trigger streaming.
 * @returns {Promise} A promise that resolves when the request is completed.
 */
// This function is used in hardware.js route to trigger the camera streams lambda function. It is implimented for camera page  and property details page in react.
function triggerCameraStreams(deviceId) {
    const url = 'https://vwwm6pzj98.execute-api.us-east-2.amazonaws.com/prod/devicehub/' + deviceId;
    const apiKey = process.env.aws_api_gateway_key;

    return new Promise((resolve, reject) => {
        const options = {
            url: url,
            method: 'GET',
            headers: {
                'x-api-key': apiKey
            }
        };

        try {
            request(options, (error, response, body) => {
                if (error) {
                    console.error(error);
                } else if (response.statusCode !== 200) {
                    console.error('API Gateway response not successful');
                } else {
                    console.log(body);
                }
                resolve(); // 
            });
        } catch (error) {
            console.error(error);
            resolve(); // Resolve the promise even in case of any errors
        }
    });
}

/**
 * Sends a request to reload the camera streams, primarily used when there are issues with the ongoing stream.
 * It makes a GET request to an API endpoint that handles the reloading of streams for specific cameras based on the device ID.
 * The function processes the response and returns either a success message or an error status.
 *
 * @param {Object} req - The request object containing the device ID and other parameters.
 * @param {Object} res - The response object used to return the result or an error.
 * @param {Function} next - Optional next middleware function for further processing.
 */
function reloadCameraStreams(req,res,next) {
    const deviceID =req.params.deviceId;
    const url = 'https://vwwm6pzj98.execute-api.us-east-2.amazonaws.com/prod/devicehub/' + deviceID;
    const apiKey = process.env.aws_api_gateway_key;

        const options = {
            url: url,
            method: 'GET',
            headers: {
                'x-api-key': apiKey
            }
        };

        try {
            request(options, (error, response, body) => {
                if (error) {
                    console.error(error);
                    return res.status(400).end();
                } else if (response.statusCode !== 200) {
                    console.error('API Gateway response not successful');
                    return res.status(400).end();
                } else {
                    console.log(body);
                    return res.json({ message: "Camera stream reloaded" })
                }
            });
        } catch (error) {
            console.error(error);
        }
}



// This function is just for testing purpose. It is not used in the project
async function getListFragments(cameraName, NextPageToken = null) {

    const configKineses = {
        region: process.env.aws_region,
        credentials: {
            accessKeyId: process.env.aws_access_key_id,
            secretAccessKey: process.env.aws_secret_access_key
        }
    };

    const client = new KinesisVideoClient(configKineses);

    // before making the ListFragmentsCommand API call, you need to call the GetDataEndpoint API to get the endpoint URL


    const dataEndpointResponse = await client.send(new GetDataEndpointCommand({
        StreamName: cameraName,
        APIName: "LIST_FRAGMENTS" // this should be specified if you want to get ListFragmentsCommand
    }));

    const dataEndpoint = dataEndpointResponse.DataEndpoint;
    // Create a new client instance with the data endpoint
    const kinesisArchivedClient = new KinesisVideoArchivedMediaClient({
        ...configKineses,
        endpoint: dataEndpoint
    });

    // Make the ListFragmentsCommand API call and pass the input parameters for ListFragmentsCommand
    const input = {
        StreamName: cameraName,
        NextToken: NextPageToken,
        FragmentSelector: {
            FragmentSelectorType: "SERVER_TIMESTAMP",
            // FragmentSelectorType: "PRODUCER_TIMESTAMP",
            TimestampRange: {
                StartTimestamp: new Date(new Date().getDate() - 2),
                EndTimestamp: new Date()
            },
        }
    };

    const command = new ListFragmentsCommand(input);
    const response = await kinesisArchivedClient.send(command);

    if (response.$metadata.httpStatusCode !== 200) {
        return [];

    }

    const fragmentArray = response.Fragments.map(fragment => fragment.FragmentNumber);

    if (fragmentArray.length === 0) {
        return [];
    }
    // console.log(fragmentArray);
    const nextPageToken = response.NextToken;
    // console.log(nextPageToken);

    try {

        // before making the GetMediaForFragmentListCommand API call, you need to call the GetDataEndpoint API to get the endpoint URL
        const endpointResponse = await client.send(new GetDataEndpointCommand({
            StreamName: cameraName,
            //api name for getMediaforFragmentList
            APIName: "GET_MEDIA_FOR_FRAGMENT_LIST" // this should be specified if you want to get the GetMediaForFragmentListCommand
        }));
        const dataEndpointPath = endpointResponse.DataEndpoint;

        const mediaClient = new KinesisVideoArchivedMediaClient({
            ...configKineses,
            endpoint: dataEndpointPath
        });

        const inputForMedia = {
            StreamName: cameraName,
            Fragments: fragmentArray
        };

        const commandForMedia = new GetMediaForFragmentListCommand(inputForMedia);
        const responseForMedia = await mediaClient.send(commandForMedia);

        if (responseForMedia.$metadata.httpStatusCode !== 200) {
            return [];
        }

        // console.log('Response For Media:', responseForMedia);
        return responseForMedia;

    } catch (error) {
        console.error(error); // Log the error for debugging purposes
        return error;

    }
}

async function getStoredHLS(name, startTimestamp, endTimestamp) {

    console.log('Start Timestamp from function:', startTimestamp);
    console.log('End Timestamp from function:', endTimestamp);

    const configKineses = {
        region: process.env.aws_region,
        credentials: {
            accessKeyId: process.env.aws_access_key_id,
            secretAccessKey: process.env.aws_secret_access_key
        }
    }

    const client = new KinesisVideoClient(configKineses);

    try {

        // before making the GetHLSStreamingSessionURL API call, you need to call the GetDataEndpoint API to get the endpoint URL
        const getDataEndpointCommand = new GetDataEndpointCommand({
            StreamName: name,
            APIName: "GET_HLS_STREAMING_SESSION_URL" // this should be specified if you want to get the HLS streaming URL
        });

        const dataEndpointResponse = await client.send(getDataEndpointCommand);
        // console.log(dataEndpointResponse);
        const dataEndpoint = dataEndpointResponse.DataEndpoint;
        // Create a new client instance with the data endpoint
        const kinesisArchivedClient = new KinesisVideoArchivedMediaClient({
            ...configKineses,
            endpoint: dataEndpoint
        });

        // Make the GetHLSStreamingSessionURL API call and pass the input parameters for the hls streaming session

        // const now = new Date();
        // const twentyFourHoursAgo = new Date();
        // twentyFourHoursAgo.setDate(now.getDate() - 1);

        const input = {
            StreamName: name,
            DisplayFragmentTimestamp: "ALWAYS", // "ALWAYS" || "NEVER",
            Expires: 43200, //12 hours
            PlaybackMode: "ON_DEMAND", //"LIVE" || "LIVE_REPLAY" || "ON_DEMAND"
            HLSFragmentSelector: { // HLSFragmentSelector
                FragmentSelectorType: "SERVER_TIMESTAMP", // SERVER_TIMESTAMP || PRODUCER_TIMESTAMP
                TimestampRange: { // HLSTimestampRange
                    StartTimestamp: new Date(startTimestamp),
                    EndTimestamp: new Date(endTimestamp),
                },
            },
            ContainerFormat: "FRAGMENTED_MP4", // "FRAGMENTED_MP4" || "MPEG_TS",
            // DiscontinuityMode: "ALWAYS" || "NEVER" || "ON_DISCONTINUITY",
            // MaxMediaPlaylistFragmentResults: Number("long"),

        };

        const command = new GetHLSStreamingSessionURLCommand(input);
        const response = await kinesisArchivedClient.send(command);
        // console.log(response);
        if (response.$metadata.httpStatusCode !== 200) {
            return null;
        }
        // console.log(response);
        return response.HLSStreamingSessionURL;

    } catch (e) {
        console.log(e);
        return null;
    }

}



//---------------------------------------- RAHMAN TEST FUNCTIONS ----------------------------------------------//
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.3</a> on Tue Jun 18 2024 12:27:25 GMT-0700 (北美太平洋夏令时间) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
